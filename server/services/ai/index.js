import asyncHandler from "express-async-handler";
import {clerkClient} from "@clerk/express";
import {STATUS_CODES,TEXTS} from "../../config/constants.js";
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const {Creation} = require("../../models/index.cjs");
import {generateContent} from "../../utils/generateContent.js";
import {removeBackground} from "../../utils/removeBG.js";
import {removeObject} from "../../utils/removeObject.js";
import {generateImage} from "../../utils/generateImage.js";
import {reviewResume} from "../../utils/reviewResume.js";

export const  generateArticle = asyncHandler(async(req,res)=>{
    const { userId } = req.auth();
    const { prompt, length } = req.body;
    const free_usage = req.free_usage;
    const plan = req.plan;


  let content;
  try {
    content = await generateContent(prompt, length);
    if (!content) {
      return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
        success:false,
        statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
        message: "No content generated by AI.",
      });
    }
  } catch (error) {
    return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
      success:false,
      statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
      message: "Failed to generate article content. Please try again later.",
    });
  }

   await Creation.create({
      user_id: userId,
      prompt,
      content,
      type: 'article'
    });

    if (plan !== "premium") {
      await clerkClient.users.updateUserMetadata(userId, {
        privateMetadata: free_usage + 1,
      });
    }

    res.status(STATUS_CODES.SUCCESS).json({
    success:true,
    statusCode: STATUS_CODES.SUCCESS,
    message: TEXTS.CREATED,
    content,
  });
})

export const generateBlogTitle = asyncHandler(async(req,res)=>{

    const { userId } = req.auth();
    const { prompt} = req.body;
    const free_usage = req.free_usage;
    const plan = req.plan;

    let content;
  try {
    content = await generateContent(prompt);
  } catch (error) {
    return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
      success:false,
      statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
      message: "Failed to generate blogtitles. Please try again later.",
    });
  }

  await Creation.create({
      user_id: userId,
      prompt,
      content,
      type: 'blog-title'
    });


    if (plan !== "premium") {
      await clerkClient.users.updateUserMetadata(userId, {
        privateMetadata: free_usage + 1,
      });
    }

    res.status(STATUS_CODES.SUCCESS).json({
    success:true,
    statusCode: STATUS_CODES.SUCCESS,
    message: TEXTS.CREATED,
    content,
  });
    
})


export const generateImages = asyncHandler(async(req,res)=>{
    const { userId } = req.auth();
    const { prompt,published} = req.body;
    // const free_usage = req.free_usage;
    // const plan = req.plan;

    let content; 
    try{
    content = await generateImage(prompt);
    await Creation.create({
      user_id: userId,
      prompt,
      content: content,
      type: 'image',
      publish: published ?? false
    });

    res.status(STATUS_CODES.SUCCESS).json({
    success:true,
    statusCode: STATUS_CODES.SUCCESS,
    message: TEXTS.CREATED,
    content,
  });
}catch(error){
  return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
      success:false,
      statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
      message: "Failed to generate Images. Please try again later.",
    });

}
})

export const removeBg = asyncHandler(async(req,res)=>{
  const { userId } = req.auth();
    // const { prompt} = req.body;
    // const free_usage = req.free_usage;
    // const plan = req.plan;
    const image = req.file;

    let content;

    try {
      content = await removeBackground(image);
      await Creation.create({
      user_id: userId,
      prompt: 'Remove the background',
      content: content,
      type: 'image'
    });

    res.status(STATUS_CODES.SUCCESS).json({
    success:true,
    statusCode: STATUS_CODES.SUCCESS,
    message: TEXTS.CREATED,
    content,
  });


    } catch (error) {
       return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
      success:false,  
      statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
      message: "Failed to remove background. Please try again later.",
    });
      
    }
  
});

export const removeObj = asyncHandler(async(req,res)=>{
  const { userId } = req.auth();
  // const { prompt} = req.body;
  const image = req.file;
  const {object} = req.body;

  let content;
    try {
      content = await removeObject(image,object);

      await Creation.create({
      user_id: userId,
      prompt: `Removed ${object} from image`,
      content: content,
      type: 'image'
    });

    res.status(STATUS_CODES.SUCCESS).json({
    success:true,  
    statusCode: STATUS_CODES.SUCCESS,
    message: TEXTS.CREATED,
    content,
  });

    } catch (error) {
      return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
      success:false,
      statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
      message: "Failed to remove object. Please try again later.",
    });
    }

});

export const resumeChecker = asyncHandler(async(req,res)=>{

   const { userId } = req.auth();
    // const { prompt} = req.body;
    // const free_usage = req.free_usage;
    // const plan = req.plan;
    const resume = req.file;

    if(resume.size > (5 * 1024 * 1024)){
    return res.json({success:false, message:"File size exceeds the limit of 5 MB"})
   }

    let content;
    try {
      content = await reviewResume(resume);
      await Creation.create({
      user_id: userId,
      prompt: 'Review the Resume',
      content : content,
      type: 'resume-review'
    });

    res.status(STATUS_CODES.SUCCESS).json({
    success:true,  
    statusCode: STATUS_CODES.SUCCESS,
    message: TEXTS.CREATED,
    content,
  });
      
    } catch (error) {
      return res.status(STATUS_CODES.INTERNAL_SERVER_ERROR).json({
      success:false,
      statusCode: STATUS_CODES.INTERNAL_SERVER_ERROR,
      message: "Failed to review resume. Please try again later.",
    });
    }
      
})